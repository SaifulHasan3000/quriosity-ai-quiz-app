This is an AI powwered quiz app that can generate quesions on any topic provided by the user
Has not a very impresive UI right now
features:
ALLOWS USER TO CHOOSE ANY TOPIC AND THE NUMBER OF QUESTIONS
HAS A LIFELINE CALLED 50:50 TO ELIMINATE 2 WRONG OPTIONS.



index.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quiz App</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>AI Quiz App</h1>
    <div id="topic-input">
      <label for="topic">Enter the topic for the quiz:</label>
      <input type="text" id="topic" required>
      <br>
      <label for="numQuestions">Enter the number of questions (1-10):</label>
      <input type="number" id="numQuestions" min="1" max="10" required>
      <br>
      <button id="start">Start Quiz</button>
    </div>
    <div id="quiz" class="hidden">
      <h2 id="question"></h2>
      <div id="options"></div>
      <p id="result"></p>
      <button id="next" style="display: none;">Next Question</button>
      <button id="submit" style="display: none;">Submit</button>
      <button id="restart" style="display: none;">Restart Quiz</button>
    </div>
    <button id="lifeline" style="display: none;">50:50 Lifeline</button>
  </div>

  <script src="index.js"></script>
</body>
</html>



styles.css:
 body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
  }
  
  .container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
  }
  
  h1 {
    text-align: center;
    color: #007bff;
  }
  
  #quiz {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  
  #topic-input,
  #quiz {
    margin-top: 20px;
  }
  
  .hidden {
    display: none;
  }
  
  #options {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }
  
  .option {
    margin: 5px;
    padding: 10px 30px;
    font-size: 16px;
    cursor: pointer;
    border: 2px solid #007bff;
    border-radius: 5px;
    background-color: #fff;
    color: #007bff;
    transition: background-color 0.3s ease;
  }
  
  .option:hover {
    background-color: #007bff;
    color: #fff;
  }
  
  #result {
    margin: 10px 0;
    font-weight: bold;
    color: #007bff;
  }
  
  #next,
  #submit,
  #restart {
    margin-top: 10px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 5px;
    background-color: #007bff;
    color: #fff;
    transition: background-color 0.3s ease;
  }
  
  #next:hover,
  #submit:hover,
  #restart:hover {
    background-color: #c1127b;
  }
  
  /* Style for topic input field */
  #topic {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    outline: none;
  }
  
  /* Style for number of questions input field */
  #numQuestions {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    outline: none;
  }
  
  /* Style for start button */
  #start {
    margin-top: 10px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 5px;
    background-color: #007bff;
    color: #fff;
    transition: background-color 0.3s ease;
  }
  
  #start:hover {
    background-color: #c1127b;
  }

/* Style for eliminated options */
.option.eliminated-option {
  background-color: #ccc;
  color: #000;
  cursor: not-allowed;
}

/* Style for lifeline button */
#lifeline {
  margin-top: 10px;
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  border: none;
  border-radius: 5px;
  background-color: #007bff;
  color: #fff;
  transition: background-color 0.3s ease;
}

#lifeline:hover {
  background-color: #c1127b;
}

#lifeline.eliminated-option {
  background-color: #ccc;
  color: #000;
  cursor: not-allowed;
}
  


index.js:
// index.js untill the options eleminamted by the lifeline becomes grey in colour
document.addEventListener("DOMContentLoaded", () => {
  const startButton = document.getElementById("start");
  const quizContainer = document.getElementById("quiz");
  const topicInput = document.getElementById("topic");
  const numQuestionsInput = document.getElementById("numQuestions");
  const questionElement = document.getElementById("question");
  const optionsContainer = document.getElementById("options");
  const resultElement = document.getElementById("result");
  const nextButton = document.getElementById("next");
  const submitButton = document.getElementById("submit");
  const restartButton = document.getElementById("restart");
  const topicInputContainer = document.getElementById("topic-input");
  const lifelineButton = document.getElementById("lifeline");

  let currentQuestionIndex = 0;
  let questions = [];
  let score = 0;
  let hasStarted = false;
  let isQuizFinished = false;
  let lifelineUsed = false;

  async function fetchQuestionsFromBackend(topic, numQuestions) {
    try {
      const response = await fetch(`/api/getQuestions?topic=${topic}&numQuestions=${numQuestions}`);
      const data = await response.json();
      questions = data.questions;
      currentQuestionIndex = 0;
      score = 0;
      isQuizFinished = false;
      lifelineUsed = false; // Reset lifeline usage when new questions are fetched
      displayQuestion();
    } catch (error) {
      console.error("Error fetching questions:", error);
    }
  }

  function displayQuestion() {
    if (isQuizFinished) {
      showScore();
      return;
    }

    const currentQuestion = questions[currentQuestionIndex];
    questionElement.innerHTML = currentQuestion.question.replace(/\n/g, "<br>");
    optionsContainer.innerHTML = "";

    currentQuestion.options.forEach((option, index) => {
      const optionButton = document.createElement("button");
      optionButton.classList.add("option");
      optionButton.textContent = option.replace(/\n/g, "");
      optionButton.dataset.option = index + 1;

      optionButton.addEventListener("mouseover", highlightOption);
      optionButton.addEventListener("mouseout", resetOptionColor);
      optionButton.addEventListener("click", selectAnswer);

      optionsContainer.appendChild(optionButton);
    });

    resultElement.textContent = "";
    nextButton.style.display = "none";
    submitButton.style.display = "none";
    lifelineButton.style.display = "block";
    lifelineButton.disabled = lifelineUsed; // Enable the lifeline button if not used on the current question
  }

  function highlightOption(event) {
    event.target.style.backgroundColor = "#1492FC";
  }

  function resetOptionColor(event) {
    event.target.style.backgroundColor = "#fff";
  }

  function selectAnswer(event) {
    if (isQuizFinished) {
      return;
    }

    const selectedOptionIndex = parseInt(event.target.dataset.option);
    const currentQuestion = questions[currentQuestionIndex];
    const isCorrect = currentQuestion.correctAnswerIndex === selectedOptionIndex;

    if (isCorrect) {
      event.target.style.backgroundColor = "green";
      score++;
      resultElement.textContent = "Correct!";
    } else {
      event.target.style.backgroundColor = "red";
      resultElement.textContent = "Oops! It's the wrong answer.";
    }

    event.target.removeEventListener("mouseover", highlightOption);
    event.target.removeEventListener("mouseout", resetOptionColor);
    event.target.removeEventListener("click", selectAnswer);

    const optionButtons = document.querySelectorAll(".option");
    optionButtons.forEach(button => button.removeEventListener("click", selectAnswer));

    if (currentQuestionIndex === questions.length - 1) {
      // Last question reached
      showSubmitButton();
    } else {
      showNextButton();
    }
  }

  function showNextButton() {
    nextButton.style.display = "block";
    submitButton.style.display = "none";
  }

  function showSubmitButton() {
    nextButton.style.display = "none";
    submitButton.style.display = "block";
  }

  function hideSubmitButton() {
    submitButton.style.display = "none";
  }

  function showScore() {
    quizContainer.classList.add("hidden");
    resultElement.textContent = `Your Score: ${score} out of ${questions.length}`;
    restartButton.style.display = "block";
    hideSubmitButton();
    lifelineButton.style.display = "none";
  }
  
    function resetLifelineButton() {
      lifelineUsed = false;
      lifelineButton.disabled = false;
      lifelineButton.classList.remove("eliminated-option");
    }
  
    function restartQuiz() {
      hasStarted = false;
      isQuizFinished = false;
      restartButton.style.display = "none";
      nextButton.style.display = "none";
      submitButton.style.display = "none";
      startButton.style.display = "block";
      topicInputContainer.classList.remove("hidden");
      questionElement.innerHTML = "";
      optionsContainer.innerHTML = "";
      resultElement.textContent = "";
      resetLifelineButton(); // Reset the lifeline button when the quiz is restarted
    }  
  
    async function useLifeline() {
      lifelineUsed = true;
      const currentQuestion = questions[currentQuestionIndex];
      const correctAnswerIndex = currentQuestion.correctAnswerIndex;
      const optionButtons = document.querySelectorAll(".option");
      let incorrectOptionsRemaining = 2;
  
      optionButtons.forEach((button, index) => {
        if (index + 1 !== correctAnswerIndex && incorrectOptionsRemaining > 0) {
          button.disabled = true;
          button.classList.add("eliminated-option"); // Add a CSS class to the eliminated options
          incorrectOptionsRemaining--;
        }
      });
  
      lifelineButton.disabled = true;
      lifelineButton.classList.add("eliminated-option"); // Add the CSS class to the lifeline button
    }
  
  

  startButton.addEventListener("click", () => {
    const topic = topicInput.value;
    const numQuestions = parseInt(numQuestionsInput.value);

    if (topic.trim() !== "" && !hasStarted && numQuestions >= 1 && numQuestions <= 10) {
      hasStarted = true;
      fetchQuestionsFromBackend(topic, numQuestions);
      quizContainer.classList.remove("hidden");
      topicInputContainer.classList.add("hidden");
    }
  });

  nextButton.addEventListener("click", () => {
    currentQuestionIndex++;
    displayQuestion();
  });

  submitButton.addEventListener("click", () => {
    isQuizFinished = true;
    hideSubmitButton();
    displayQuestion();
  });

  restartButton.addEventListener("click", () => {
    restartQuiz();
  });

  lifelineButton.addEventListener("click", () => {
    if (hasStarted && !isQuizFinished && !lifelineUsed) {
      useLifeline();
    }
  });
});





server.js:
const express = require("express");
const axios = require("axios");
const { Configuration, OpenAIApi } = require("openai");
const path = require("path");

require('dotenv').config();

const app = express();
const port = process.env.PORT || 3000;

const configuration = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
});
const openai = new OpenAIApi(configuration);

app.use(express.json());

app.get("/api/getQuestions", async (req, res) => {
  const { topic, numQuestions } = req.query;

  try {
    const questions = await generateQuestionsForTopic(topic, numQuestions);
    res.json({ questions });
  } catch (error) {
    console.error("Error fetching questions:", error);
    res.status(500).json({ error: "Failed to fetch questions." });
  }
});

app.post("/api/evaluateAnswer", (req, res) => {
  const { questionIndex, selectedAnswerIndex } = req.body;
  const question = quizQuestions[questionIndex];
  const isCorrect = question.correctAnswerIndex === selectedAnswerIndex;
  res.json({ isCorrect });
});

async function findCorrectAnswerIndex(response) {
  const correctAnswerIndexRegex = /{(\d)}/;
  const match = response.match(correctAnswerIndexRegex);
  if (match) {
    return parseInt(match[1]);
  }
  return -1;
}

async function generateQuestionsForTopic(topic, numQuestions) {
  const prompt = `Give me a random question along with 4 options on the topic - ${topic}
  Formatting rules to be strictly followed:
  only question statement should be there on the first line. No need to respond "Question:" and then respond with the actual statement, rather just give the actual question statement only here
  the options should be numbered as 1), 2), 3) and 4)
  The options should be given ou in separate lines
  and after giving out this, enclose the correct option number in curly brackets "{}" (example for this: if the correct option number is 4 then {4} should be there in your response at the end and NOTHING ELSE).
  Just return these things and no extra characters or words.`;
  
  try {
    const questions = [];

    for (let i = 0; i < numQuestions; i++) {
      const completion = await openai.createCompletion({
        model: "text-davinci-003",
        prompt,
        max_tokens: 150,
      });
  
      const response = completion.data.choices[0].text.trim();
      const formattedResponse = response.replace(/\n(\w\))/g, "\n$1 ");
      const options = response.match(/\w\)/g).map(opt => opt.trim());
      const correctAnswerIndex = await findCorrectAnswerIndex(response);
  
      const question = {
        question: formattedResponse.replace(/\s*{\d}\s*$/, ""),
        options: options,
        correctAnswerIndex: correctAnswerIndex
      };
  
      questions.push(question);
    }

    return questions;
  } catch (error) {
    console.error("Error generating questions:", error);
    throw new Error("Failed to generate questions.");
  }
}

app.use(express.static(path.join(__dirname, "frontend")));

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});





.env file: storiing the OpenAI API key
OPENAI_API_KEY="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"
